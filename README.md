# leetcode_hot100
刷题刷题

## 回溯与动态规划
- 回溯 
  - 像走迷宫，遇到死路就退回岔路口换方向。通过试错探索所有可能路径，常用于穷举问题（如八皇后）。
  - 代码实现通常是递归+撤销操作（比如棋盘上落子后撤回）。
  - 回溯，通常是在「递」的过程中增量地构建答案，并在失败时能够回退。

- 动态规划
  - 通过将问题分解为子问题并存储子问题的解来优化递归。
  - 像背单词时先背简单词再记复杂词。
  - 将问题分解为相互关联的子问题，并存储子问题的解避免重复计算。
  - 比如斐波那契数列，算f(5)需要f(4)和f(3)，而f(4)又需要f(3)和f(2)，此时存下中间结果能大幅减少计算量。
  - 动态规划常被看作“递归+记忆化”，
  - 与回溯的区别在于动态规划有重叠子问题和最优子结构
- 使用res保持结果 or 直接return 场景区别
  - 需要所有解 → 回溯法 + res。
  - 只需存在性/单一解 → DFS直接返回。
  - 子问题重叠 → DP + 返回当前节点代表的值 + 记忆化。
## 到底是return dfs(n-1) 还是 return ans
1. **检查递归函数的定义**：
   - 如果 `dfs` 的返回值直接就是问题的答案（如 LCS 的长度、树的高度），则直接 `return dfs(全局参数)`。
   - 如果 `dfs` 的返回值是子问题的局部信息（如子树深度），而答案需要从这些局部信息中进一步计算或比较（如直径），则需要 `ans`。

2. **是否需要全局信息**：
   - 如果答案是递归函数在特定参数下的直接结果，无需跨分支比较或累积，则直接返回 `dfs`。
   - 如果答案需要在递归的多个分支中寻找最优解（如最大值、最小值），则需要维护 `ans`。
3. 如果使用的是直接return `dfs`，则肯定不需要全局的ans了；如果
## 动态规划中，DP数组的初始化长度是n还是n+1？
- 在DFS写法中，边界条件如果是小于0，比如：if i<0 ...，则选择初始化长度为n+1
- 反之，如果边界条件是等于0，比如：if i==0 ...，则选择初始化长度为n
                          
## dfs正序还好是逆序？
- 正序DFS：用于组合、排列问题，通过 start 限制选择范围，避免重复组合。（例题：39. 组合总和、78. 子集）
- 逆序DFS：常用于。
- 核心原则：根据问题的唯一性要求选择顺序，确保不重复计算或遗漏解。